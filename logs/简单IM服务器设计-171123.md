# Replay
本来打算通过设计一个简单的通信协议，借此完成协议编解码模块。但是实际抽象的结果，犹如浮沙筑高阁。

最开始，打算效仿go的encoder/decoder方案，设计一个decoder，任意类型的数据传入后，自动完成编
解码。
```c++
template<typename T>
void MyDecoder::unmarshal(BinaryReader in, T& out)
```

如果这么写，那么每当一种新的类型出现，decoder都要重载一次unmarshal，而且还必须知道T类型是如何
序列化的。

如果希望一个Decoder，传入任何类型的变量，他都能解码，那这个Decoder势必要知道所有的编码方式，并
且任意一个编码方式改变，Decoder都要随改变。

这种Decoder是不应该存在的。

合理的方式是，每个类型，自带自己的编解码说明书，对外提供输出接口，外部直接调用该接口完成编码即可。

这个留待下次修改掉。


## 不要为了抽象而抽象
本来预计一天搞完的，实际上花了两天。一开始，在没有对编解码方案做好好思考的情况下写出过这样的代码：
```c++
class Decoer {
template<typename T>
virtual void unmarshal(BinaryReader in, T& out);
};
```

实际上连编译都编译不过。虚函数不能带模版。

其实都是因为一昧的想效仿go的接口设计，强行做抽象导致的。 

如果要做抽象，先对要抽象的事务做充分的调查，看看这些东西，能不能抽象，抽象什么，怎么抽象。如果
一个东西，你都没见过几个，全靠空想，假设，去抽象，那就是在浪费时间。

这些都是要花时间去调查，去总结的，如果不打算花这个时间，那也行，不要做抽象，简简单单的写个函数
完成功能就行了，也没问题，以后使用的多了，有必要抽象的时候再来做。不要凭空抽象，为了抽象而抽象，
浪费时间，自增烦恼！

当你都不知道你在抽象什么的时候，千万不要尝试去抽象！